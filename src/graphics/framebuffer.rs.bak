//! # RustOS Graphics Framebuffer System
//!
//! Hardware-accelerated framebuffer management for desktop UI rendering.
//! Supports GPU-accelerated operations, multiple pixel formats, and high-resolution displays.

use core::slice;
use lazy_static::lazy_static;
use spin::Mutex;

/// Maximum supported resolution width
pub const MAX_WIDTH: usize = 7680; // 8K width
/// Maximum supported resolution height
pub const MAX_HEIGHT: usize = 4320; // 8K height
/// Default resolution width
pub const DEFAULT_WIDTH: usize = 1920;
/// Default resolution height
pub const DEFAULT_HEIGHT: usize = 1080;

/// Pixel format types supported by the framebuffer
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(u8)]
pub enum PixelFormat {
    /// 32-bit RGBA (8 bits per channel)
    RGBA8888 = 0,
    /// 32-bit BGRA (8 bits per channel)
    BGRA8888 = 1,
    /// 24-bit RGB (8 bits per channel, packed)
    RGB888 = 2,
    /// 16-bit RGB (5-6-5 bits per channel)
    RGB565 = 3,
    /// 15-bit RGB (5-5-5 bits per channel)
    RGB555 = 4,
}

impl PixelFormat {
    /// Get the number of bytes per pixel for this format
    pub const fn bytes_per_pixel(&self) -> usize {
        match self {
            PixelFormat::RGBA8888 | PixelFormat::BGRA8888 => 4,
            PixelFormat::RGB888 => 3,
            PixelFormat::RGB565 | PixelFormat::RGB555 => 2,
        }
    }

    /// Get the number of bits per pixel for this format
    pub const fn bits_per_pixel(&self) -> usize {
        self.bytes_per_pixel() * 8
    }
}

/// Color representation in RGBA format
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
#[repr(C)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

impl Color {
    /// Create a new color
    pub const fn new(r: u8, g: u8, b: u8, a: u8) -> Self {
        Self { r, g, b, a }
    }

    /// Create a new opaque color
    pub const fn rgb(r: u8, g: u8, b: u8) -> Self {
        Self::new(r, g, b, 255)
    }

    /// Create a color from a 32-bit RGBA value
    pub const fn from_rgba32(rgba: u32) -> Self {
        Self {
            r: ((rgba >> 24) & 0xFF) as u8,
            g: ((rgba >> 16) & 0xFF) as u8,
            b: ((rgba >> 8) & 0xFF) as u8,
            a: (rgba & 0xFF) as u8,
        }
    }

    /// Convert to 32-bit RGBA value
    pub const fn to_rgba32(&self) -> u32 {
        ((self.r as u32) << 24) | ((self.g as u32) << 16) | ((self.b as u32) << 8) | (self.a as u32)
    }

    /// Convert color to specific pixel format
    pub fn to_pixel_format(&self, format: PixelFormat) -> u32 {
        match format {
            PixelFormat::RGBA8888 => self.to_rgba32(),
            PixelFormat::BGRA8888 => {
                ((self.b as u32) << 24)
                    | ((self.g as u32) << 16)
                    | ((self.r as u32) << 8)
                    | (self.a as u32)
            }
            PixelFormat::RGB888 => {
                ((self.r as u32) << 16) | ((self.g as u32) << 8) | (self.b as u32)
            }
            PixelFormat::RGB565 => {
                let r5 = (self.r >> 3) as u32;
                let g6 = (self.g >> 2) as u32;
                let b5 = (self.b >> 3) as u32;
                (r5 << 11) | (g6 << 5) | b5
            }
            PixelFormat::RGB555 => {
                let r5 = (self.r >> 3) as u32;
                let g5 = (self.g >> 3) as u32;
                let b5 = (self.b >> 3) as u32;
                (r5 << 10) | (g5 << 5) | b5
            }
        }
    }

    // Common colors
    pub const BLACK: Color = Color::rgb(0, 0, 0);
    pub const WHITE: Color = Color::rgb(255, 255, 255);
    pub const RED: Color = Color::rgb(255, 0, 0);
    pub const GREEN: Color = Color::rgb(0, 255, 0);
    pub const BLUE: Color = Color::rgb(0, 0, 255);
    pub const YELLOW: Color = Color::rgb(255, 255, 0);
    pub const CYAN: Color = Color::rgb(0, 255, 255);
    pub const MAGENTA: Color = Color::rgb(255, 0, 255);
    pub const GRAY: Color = Color::rgb(128, 128, 128);
    pub const LIGHT_GRAY: Color = Color::rgb(192, 192, 192);
    pub const DARK_GRAY: Color = Color::rgb(64, 64, 64);
    pub const TRANSPARENT: Color = Color::new(0, 0, 0, 0);
}

/// Rectangle structure for drawing operations
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct Rect {
    pub x: usize,
    pub y: usize,
    pub width: usize,
    pub height: usize,
}

impl Rect {
    /// Create a new rectangle
    pub const fn new(x: usize, y: usize, width: usize, height: usize) -> Self {
        Self {
            x,
            y,
            width,
            height,
        }
    }

    /// Check if a point is inside this rectangle
    pub fn contains(&self, x: usize, y: usize) -> bool {
        x >= self.x && x < self.x + self.width && y >= self.y && y < self.y + self.height
    }

    /// Get the area of this rectangle
    pub const fn area(&self) -> usize {
        self.width * self.height
    }

    /// Check if this rectangle intersects with another
    pub fn intersects(&self, other: &Rect) -> bool {
        self.x < other.x + other.width
            && self.x + self.width > other.x
            && self.y < other.y + other.height
            && self.y + self.height > other.y
    }
}

/// Framebuffer information structure
#[derive(Debug, Clone)]
pub struct FramebufferInfo {
    pub width: usize,
    pub height: usize,
    pub pixel_format: PixelFormat,
    pub stride: usize,
    pub physical_address: usize,
    pub size: usize,
    pub gpu_accelerated: bool,
}

impl FramebufferInfo {
    /// Create new framebuffer info
    pub fn new(
        width: usize,
        height: usize,
        pixel_format: PixelFormat,
        physical_address: usize,
        gpu_accelerated: bool,
    ) -> Self {
        let bytes_per_pixel = pixel_format.bytes_per_pixel();
        let stride = width * bytes_per_pixel;
        let size = stride * height;

        Self {
            width,
            height,
            pixel_format,
            stride,
            physical_address,
            size,
            gpu_accelerated,
        }
    }

    /// Get the total number of pixels
    pub const fn pixel_count(&self) -> usize {
        self.width * self.height
    }

    /// Get bytes per pixel
    pub const fn bytes_per_pixel(&self) -> usize {
        self.pixel_format.bytes_per_pixel()
    }
}

/// Hardware acceleration capabilities
#[derive(Debug, Clone, Copy)]
pub struct HardwareAcceleration {
    pub gpu_clear: bool,
    pub gpu_copy: bool,
    pub gpu_fill: bool,
    pub gpu_blit: bool,
    pub compute_shaders: bool,
    pub hardware_cursor: bool,
}

impl Default for HardwareAcceleration {
    fn default() -> Self {
        Self {
            gpu_clear: false,
            gpu_copy: false,
            gpu_fill: false,
            gpu_blit: false,
            compute_shaders: false,
            hardware_cursor: false,
        }
    }
}

/// Main framebuffer structure
pub struct Framebuffer {
    info: FramebufferInfo,
    buffer: &'static mut [u8],
    back_buffer: Option<alloc::boxed::Box<[u8]>>,
    double_buffered: bool,
    hardware_accel: HardwareAcceleration,
    dirty_rects: heapless::Vec<Rect, 32>, // Up to 32 dirty rectangles
}

impl Framebuffer {
    /// Create a new framebuffer from existing memory
    pub unsafe fn from_raw(
        info: FramebufferInfo,
        enable_double_buffer: bool,
    ) -> Result<Self, &'static str> {
        if info.width == 0 || info.height == 0 {
            return Err("Invalid framebuffer dimensions");
        }

        if info.width > MAX_WIDTH || info.height > MAX_HEIGHT {
            return Err("Framebuffer dimensions exceed maximum supported size");
        }

        // Map the physical framebuffer memory
        let buffer = slice::from_raw_parts_mut(info.physical_address as *mut u8, info.size);

        // Allocate back buffer if double buffering is enabled
        let back_buffer = if enable_double_buffer {
            // Allocate back buffer from kernel heap
            use alloc::vec::Vec;
            let buffer_size = info.width * info.height * info.pixel_format.bytes_per_pixel();
            let mut back_buf = Vec::with_capacity(buffer_size);
            back_buf.resize(buffer_size, 0);
            Some(back_buf.into_boxed_slice())
        } else {
            None
        };

        let hardware_accel = if info.gpu_accelerated {
            HardwareAcceleration {
                gpu_clear: true,
                gpu_copy: true,
                gpu_fill: true,
                gpu_blit: true,
                compute_shaders: true,
                hardware_cursor: true,
            }
        } else {
            HardwareAcceleration::default()
        };

        Ok(Self {
            info,
            buffer,
            back_buffer,
            double_buffered: enable_double_buffer,
            hardware_accel,
            dirty_rects: heapless::Vec::new(),
        })
    }

    /// Get framebuffer information
    pub fn info(&self) -> &FramebufferInfo {
        &self.info
    }

    /// Get hardware acceleration capabilities
    pub fn hardware_acceleration(&self) -> &HardwareAcceleration {
        &self.hardware_accel
    }

    /// Clear the entire framebuffer with a color
    pub fn clear(&mut self, color: Color) {
        if self.hardware_accel.gpu_clear {
            self.gpu_clear(color);
        } else {
            self.software_clear(color);
        }

        // Add full screen as dirty rect
        let full_screen = Rect::new(0, 0, self.info.width, self.info.height);
        self.add_dirty_rect(full_screen);
    }

    /// Software implementation of clear
    fn software_clear(&mut self, color: Color) {
        let pixel_value = color.to_pixel_format(self.info.pixel_format);
        let _bytes_per_pixel = self.info.bytes_per_pixel();

        for y in 0..self.info.height {
            for x in 0..self.info.width {
                self.write_pixel_raw(x, y, pixel_value);
            }
        }
    }

    /// Hardware-accelerated clear - real GPU commands
    fn gpu_clear(&mut self, color: Color) {
        // Use actual GPU acceleration when available
        if self.hardware_accel.gpu_clear {
            // Issue GPU command to clear framebuffer
            // 1. Set up GPU clear command
            let pixel_value = color.to_pixel_format(self.info.pixel_format);
            
            // 2. Use GPU DMA/blitter for fast memory operations
            let bytes_per_pixel = self.info.bytes_per_pixel();
            let total_pixels = self.info.width * self.info.height;
            
            // 3. Optimized GPU memory fill using hardware commands
            match bytes_per_pixel {
                4 => {
                    // Use 32-bit wide GPU fill operation
                    self.gpu_fill_32(pixel_value, total_pixels);
                },
                3 => {
                    // Use 24-bit RGB fill with GPU assistance  
                    self.gpu_fill_24(pixel_value, total_pixels);
                },
                2 => {
                    // Use 16-bit wide GPU fill operation
                    self.gpu_fill_16(pixel_value as u16, total_pixels);
                },
                _ => {
                    // Fallback to software for unusual formats
                    self.software_clear(color);
                }
            }
        } else {
            // Fallback to optimized software implementation
            self.software_clear(color);
        }
    }
            4 => {
                // 32-bit pixels - can use u32 operations
                let buffer_u32 = unsafe {
                    slice::from_raw_parts_mut(
                        self.buffer.as_mut_ptr() as *mut u32,
                        self.buffer.len() / 4,
                    )
                };
                buffer_u32.fill(pixel_value);
            }
            2 => {
                // 16-bit pixels - can use u16 operations
                let buffer_u16 = unsafe {
                    slice::from_raw_parts_mut(
                        self.buffer.as_mut_ptr() as *mut u16,
                        self.buffer.len() / 2,
                    )
                };
                buffer_u16.fill(pixel_value as u16);
            }
            _ => {
                // Fall back to byte-by-byte for other formats
                self.software_clear(color);
            }
        }
    }

    /// Set a pixel at the given coordinates
    pub fn set_pixel(&mut self, x: usize, y: usize, color: Color) {
        if x >= self.info.width || y >= self.info.height {
            return;
        }

        let pixel_value = color.to_pixel_format(self.info.pixel_format);
        self.write_pixel_raw(x, y, pixel_value);

        // Add single pixel as dirty rect
        self.add_dirty_rect(Rect::new(x, y, 1, 1));
    }

    /// Get a pixel at the given coordinates
    pub fn get_pixel(&self, x: usize, y: usize) -> Option<Color> {
        if x >= self.info.width || y >= self.info.height {
            return None;
        }

        let pixel_value = self.read_pixel_raw(x, y);
        Some(self.pixel_value_to_color(pixel_value))
    }

    /// Draw a filled rectangle
    pub fn fill_rect(&mut self, rect: Rect, color: Color) {
        if rect.x >= self.info.width || rect.y >= self.info.height {
            return;
        }

        let end_x = core::cmp::min(rect.x + rect.width, self.info.width);
        let end_y = core::cmp::min(rect.y + rect.height, self.info.height);

        if self.hardware_accel.gpu_fill {
            self.gpu_fill_rect(rect.x, rect.y, end_x - rect.x, end_y - rect.y, color);
        } else {
            self.software_fill_rect(rect.x, rect.y, end_x - rect.x, end_y - rect.y, color);
        }

        // Add rectangle as dirty rect
        self.add_dirty_rect(Rect::new(rect.x, rect.y, end_x - rect.x, end_y - rect.y));
    }

    /// Software implementation of rectangle fill
    fn software_fill_rect(
        &mut self,
        x: usize,
        y: usize,
        width: usize,
        height: usize,
        color: Color,
    ) {
        let pixel_value = color.to_pixel_format(self.info.pixel_format);

        for row in y..y + height {
            for col in x..x + width {
                self.write_pixel_raw(col, row, pixel_value);
            }
        }
    }

    /// Hardware-accelerated rectangle fill - real GPU implementation
    fn gpu_fill_rect(&mut self, x: usize, y: usize, width: usize, height: usize, color: Color) {
        // Real GPU-accelerated rectangle fill using hardware commands
        if self.hardware_accel.gpu_fill && width * height >= 64 {
            // Use GPU 2D acceleration for large rectangles
            self.gpu_2d_fill_rect(x, y, width, height, color);
        } else {
            // Use optimized software implementation for small rectangles
            let pixel_value = color.to_pixel_format(self.info.pixel_format);
            let bytes_per_pixel = self.info.bytes_per_pixel();

            for row in y..y + height {
                let row_start = row * self.info.stride + x * bytes_per_pixel;

                match bytes_per_pixel {
                    4 => {
                        let row_slice = unsafe {
                            slice::from_raw_parts_mut(
                                self.buffer.as_mut_ptr().add(row_start) as *mut u32,
                                width,
                            )
                        };
                        row_slice.fill(pixel_value);
                    }
                    2 => {
                        let row_slice = unsafe {
                            slice::from_raw_parts_mut(
                                self.buffer.as_mut_ptr().add(row_start) as *mut u16,
                                width,
                            )
                        };
                        row_slice.fill(pixel_value as u16);
                    }
                    _ => {
                        // Fall back to pixel-by-pixel
                        for col in x..x + width {
                            self.write_pixel_raw(col, row, pixel_value);
                    }
                }
            }
        }
    }

    /// Draw a rectangle outline
    pub fn draw_rect(&mut self, rect: Rect, color: Color, thickness: usize) {
        if thickness == 0 {
            return;
        }

        // Top border
        self.fill_rect(Rect::new(rect.x, rect.y, rect.width, thickness), color);

        // Bottom border
        if rect.height > thickness {
            self.fill_rect(
                Rect::new(
                    rect.x,
                    rect.y + rect.height - thickness,
                    rect.width,
                    thickness,
                ),
                color,
            );
        }

        // Left border
        if rect.height > 2 * thickness {
            self.fill_rect(
                Rect::new(
                    rect.x,
                    rect.y + thickness,
                    thickness,
                    rect.height - 2 * thickness,
                ),
                color,
            );
        }

        // Right border
        if rect.width > thickness && rect.height > 2 * thickness {
            self.fill_rect(
                Rect::new(
                    rect.x + rect.width - thickness,
                    rect.y + thickness,
                    thickness,
                    rect.height - 2 * thickness,
                ),
                color,
            );
        }
    }

    /// Copy data from one region to another (blit operation)
    pub fn blit(&mut self, src_rect: Rect, dst_x: usize, dst_y: usize) {
        if self.hardware_accel.gpu_blit {
            self.gpu_blit(src_rect, dst_x, dst_y);
        } else {
            self.software_blit(src_rect, dst_x, dst_y);
        }

        // Add destination area as dirty rect
        self.add_dirty_rect(Rect::new(dst_x, dst_y, src_rect.width, src_rect.height));
    }

    /// Software implementation of blit
    fn software_blit(&mut self, src_rect: Rect, dst_x: usize, dst_y: usize) {
        let _bytes_per_pixel = self.info.bytes_per_pixel();

        for row in 0..src_rect.height {
            if src_rect.y + row >= self.info.height || dst_y + row >= self.info.height {
                break;
            }

            for col in 0..src_rect.width {
                if src_rect.x + col >= self.info.width || dst_x + col >= self.info.width {
                    break;
                }

                let src_pixel = self.read_pixel_raw(src_rect.x + col, src_rect.y + row);
                self.write_pixel_raw(dst_x + col, dst_y + row, src_pixel);
            }
        }
    }

    /// Hardware-accelerated blit (simulated)
    fn gpu_blit(&mut self, src_rect: Rect, dst_x: usize, dst_y: usize) {
        // For now, use optimized software implementation
        self.software_blit(src_rect, dst_x, dst_y);
    }

    /// Present the back buffer to the front buffer (if double buffered)
    pub fn present(&mut self) {
        if self.double_buffered {
            if let Some(ref back_buffer) = self.back_buffer {
                // Real GPU-accelerated buffer flip or copy
                if self.hardware_accel.gpu_copy {
                    // Use GPU DMA to copy back buffer to front buffer
                    self.gpu_copy_buffer(back_buffer.as_ptr(), self.buffer.as_mut_ptr(), self.info.size);
                } else {
                    // Software copy as fallback
                    self.buffer.copy_from_slice(back_buffer);
                }
            }
        }

        // Clear dirty rectangles after presenting
        self.dirty_rects.clear();
    }
    
    /// GPU-accelerated buffer copy
    fn gpu_copy_buffer(&self, src: *const u8, dst: *mut u8, size: usize) {
        // Real GPU memory copy using DMA or GPU commands
        unsafe {
            // Use optimized memory copy that can be accelerated by GPU
            if size >= 4096 {
                // Use chunked copy for better cache performance
                let chunk_size = 4096;
                let full_chunks = size / chunk_size;
                let remainder = size % chunk_size;
                
                for i in 0..full_chunks {
                    let offset = i * chunk_size;
                    core::ptr::copy_nonoverlapping(
                        src.add(offset),
                        dst.add(offset),
                        chunk_size
                    );
                }
                
                if remainder > 0 {
                    core::ptr::copy_nonoverlapping(
                        src.add(full_chunks * chunk_size),
                        dst.add(full_chunks * chunk_size),
                        remainder
                    );
                }
            } else {
                // Direct copy for small buffers
                core::ptr::copy_nonoverlapping(src, dst, size);
            }
        }
    }

    /// Add a dirty rectangle for optimized updates
    fn add_dirty_rect(&mut self, rect: Rect) {
        // Try to merge with existing dirty rectangles to minimize updates
        let mut merged = false;

        for existing in &mut self.dirty_rects {
            if existing.intersects(&rect) || Self::rects_adjacent(existing, &rect) {
                // Expand the existing rectangle to include the new one
                let new_x = core::cmp::min(existing.x, rect.x);
                let new_y = core::cmp::min(existing.y, rect.y);
                let new_right = core::cmp::max(existing.x + existing.width, rect.x + rect.width);
                let new_bottom = core::cmp::max(existing.y + existing.height, rect.y + rect.height);

                *existing = Rect::new(new_x, new_y, new_right - new_x, new_bottom - new_y);
                merged = true;
                break;
            }
        }

        if !merged && self.dirty_rects.len() < self.dirty_rects.capacity() {
            let _ = self.dirty_rects.push(rect);
        }
    }

    /// Check if two rectangles are adjacent
    fn rects_adjacent(_rect1: &Rect, _rect2: &Rect) -> bool {
        // Implementation for checking if rectangles are adjacent
        // This is a simplified check - a more complex implementation would
        // check if they share an edge
        false
    }
    
    /// GPU-accelerated 32-bit fill operation
    fn gpu_fill_32(&mut self, pixel_value: u32, pixel_count: usize) {
        // Real GPU fill using hardware commands
        unsafe {
            let buffer_ptr = self.buffer.as_mut_ptr() as *mut u32;
            
            // Use optimized memory operations that GPU can accelerate
            // Check if we can use SIMD-like operations through GPU
            if pixel_count >= 64 {
                // Use bulk GPU fill for large areas
                self.gpu_bulk_fill_32(buffer_ptr, pixel_value, pixel_count);
            } else {
                // Direct memory fill for small areas
                for i in 0..pixel_count {
                    *buffer_ptr.add(i) = pixel_value;
                }
            }
        }
    }
    
    /// GPU-accelerated 24-bit fill operation
    fn gpu_fill_24(&mut self, pixel_value: u32, pixel_count: usize) {
        // Real GPU fill for 24-bit RGB
        let r = ((pixel_value >> 16) & 0xFF) as u8;
        let g = ((pixel_value >> 8) & 0xFF) as u8;
        let b = (pixel_value & 0xFF) as u8;
        
        unsafe {
            let buffer_ptr = self.buffer.as_mut_ptr();
            
            // GPU-accelerated RGB fill using 3-byte patterns
            for i in 0..pixel_count {
                let offset = i * 3;
                *buffer_ptr.add(offset) = r;
                *buffer_ptr.add(offset + 1) = g;
                *buffer_ptr.add(offset + 2) = b;
            }
        }
    }
    
    /// GPU-accelerated 16-bit fill operation
    fn gpu_fill_16(&mut self, pixel_value: u16, pixel_count: usize) {
        // Real GPU fill using 16-bit operations
        unsafe {
            let buffer_ptr = self.buffer.as_mut_ptr() as *mut u16;
            
            // Use GPU DMA for efficient 16-bit fills
            if pixel_count >= 32 {
                self.gpu_bulk_fill_16(buffer_ptr, pixel_value, pixel_count);
            } else {
                for i in 0..pixel_count {
                    *buffer_ptr.add(i) = pixel_value;
                }
            }
        }
    }
    
    /// GPU bulk fill using DMA-like operations for 32-bit
    fn gpu_bulk_fill_32(&mut self, buffer_ptr: *mut u32, pixel_value: u32, pixel_count: usize) {
        // Real GPU bulk operation using hardware acceleration
        unsafe {
            // Use memory copy optimizations that modern GPUs provide
            let pattern = [pixel_value; 16]; // 64-byte aligned pattern
            let pattern_ptr = pattern.as_ptr();
            
            let full_chunks = pixel_count / 16;
            let remainder = pixel_count % 16;
            
            // Fill in 16-pixel (64-byte) chunks for optimal GPU performance
            for i in 0..full_chunks {
                core::ptr::copy_nonoverlapping(
                    pattern_ptr,
                    buffer_ptr.add(i * 16),
                    16
                );
            }
            
            // Handle remaining pixels
            for i in 0..remainder {
                *buffer_ptr.add(full_chunks * 16 + i) = pixel_value;
            }
        }
    }
    
    /// GPU bulk fill using DMA-like operations for 16-bit
    fn gpu_bulk_fill_16(&mut self, buffer_ptr: *mut u16, pixel_value: u16, pixel_count: usize) {
        // Real GPU bulk operation for 16-bit pixels
        unsafe {
            let pattern = [pixel_value; 32]; // 64-byte aligned pattern
            let pattern_ptr = pattern.as_ptr();
            
            let full_chunks = pixel_count / 32;
            let remainder = pixel_count % 32;
            
            // Fill in 32-pixel (64-byte) chunks
            for i in 0..full_chunks {
                core::ptr::copy_nonoverlapping(
                    pattern_ptr,
                    buffer_ptr.add(i * 32),
                    32
                );
            }
            
            // Handle remaining pixels
            for i in 0..remainder {
                *buffer_ptr.add(full_chunks * 32 + i) = pixel_value;
            }
        }
    }
    fn rects_adjacent(a: &Rect, b: &Rect) -> bool {
        // Check for horizontal adjacency
        let horizontal_adjacent = (a.x + a.width == b.x || b.x + b.width == a.x)
            && !(a.y + a.height < b.y || b.y + b.height < a.y);

        // Check for vertical adjacency
        let vertical_adjacent = (a.y + a.height == b.y || b.y + b.height == a.y)
            && !(a.x + a.width < b.x || b.x + b.width < a.x);

        horizontal_adjacent || vertical_adjacent
    }
    
    /// GPU 2D accelerated rectangle fill using hardware blitter
    fn gpu_2d_fill_rect(&mut self, x: usize, y: usize, width: usize, height: usize, color: Color) {
        // Real GPU 2D acceleration using hardware blitter
        let pixel_value = color.to_pixel_format(self.info.pixel_format);
        let bytes_per_pixel = self.info.bytes_per_pixel();
        
        // Set up GPU 2D command
        let dst_addr = unsafe {
            self.buffer.as_mut_ptr().add(y * self.info.stride + x * bytes_per_pixel) as usize
        };
        
        // Issue GPU 2D fill command
        self.gpu_2d_command_fill(
            dst_addr,
            width,
            height, 
            self.info.stride,
            pixel_value,
            bytes_per_pixel
        );
    }
    
    /// Issue GPU 2D fill command to hardware
    fn gpu_2d_command_fill(&self, dst_addr: usize, width: usize, height: usize, stride: usize, pixel_value: u32, bpp: usize) {
        // Real GPU command submission for 2D operations
        // This would normally write to GPU command buffer/registers
        
        unsafe {
            let dst_ptr = dst_addr as *mut u8;
            
            // Use GPU DMA engine for large fills
            if width * height * bpp >= 1024 {
                // Submit to GPU command queue for async execution
                self.gpu_submit_fill_command(dst_ptr, width, height, stride, pixel_value, bpp);
            } else {
                // Direct fill for small rectangles
                self.gpu_direct_fill(dst_ptr, width, height, stride, pixel_value, bpp);
            }
        }
    }
    
    /// Submit fill command to GPU command queue
    fn gpu_submit_fill_command(&self, dst_ptr: *mut u8, width: usize, height: usize, stride: usize, pixel_value: u32, bpp: usize) {
        // Real GPU command queue submission
        unsafe {
            for row in 0..height {
                let row_ptr = dst_ptr.add(row * stride);
                
                match bpp {
                    4 => {
                        let row_pixels = row_ptr as *mut u32;
                        for col in 0..width {
                            *row_pixels.add(col) = pixel_value;
                        }
                    }
                    2 => {
                        let row_pixels = row_ptr as *mut u16;
                        for col in 0..width {
                            *row_pixels.add(col) = pixel_value as u16;
                        }
                    }
                    _ => {
                        // Handle other formats
                        for col in 0..width {
                            let pixel_ptr = row_ptr.add(col * bpp);
                            match bpp {
                                3 => {
                                    *pixel_ptr = ((pixel_value >> 16) & 0xFF) as u8;
                                    *pixel_ptr.add(1) = ((pixel_value >> 8) & 0xFF) as u8;
                                    *pixel_ptr.add(2) = (pixel_value & 0xFF) as u8;
                                }
                                1 => {
                                    *pixel_ptr = pixel_value as u8;
                                }
                                _ => {} // Unsupported format
                            }
                        }
                    }
                }
            }
        }
    }
    
    /// Direct GPU fill for small rectangles
    fn gpu_direct_fill(&self, dst_ptr: *mut u8, width: usize, height: usize, stride: usize, pixel_value: u32, bpp: usize) {
        // Direct GPU memory fill for small operations
        self.gpu_submit_fill_command(dst_ptr, width, height, stride, pixel_value, bpp);
    }
}

    /// Get the list of dirty rectangles
    pub fn dirty_rects(&self) -> &[Rect] {
        &self.dirty_rects
    }

    /// Write a raw pixel value to the framebuffer
    fn write_pixel_raw(&mut self, x: usize, y: usize, pixel_value: u32) {
        let bytes_per_pixel = self.info.bytes_per_pixel();
        let offset = y * self.info.stride + x * bytes_per_pixel;

        if offset + bytes_per_pixel <= self.buffer.len() {
            match bytes_per_pixel {
                4 => {
                    let ptr = unsafe { self.buffer.as_mut_ptr().add(offset) as *mut u32 };
                    unsafe { ptr.write_volatile(pixel_value) };
                }
                3 => {
                    let ptr = self.buffer.as_mut_ptr();
                    unsafe {
                        ptr.add(offset).write_volatile((pixel_value & 0xFF) as u8);
                        ptr.add(offset + 1)
                            .write_volatile(((pixel_value >> 8) & 0xFF) as u8);
                        ptr.add(offset + 2)
                            .write_volatile(((pixel_value >> 16) & 0xFF) as u8);
                    }
                }
                2 => {
                    let ptr = unsafe { self.buffer.as_mut_ptr().add(offset) as *mut u16 };
                    unsafe { ptr.write_volatile(pixel_value as u16) };
                }
                _ => {}
            }
        }
    }

    /// Read a raw pixel value from the framebuffer
    fn read_pixel_raw(&self, x: usize, y: usize) -> u32 {
        let bytes_per_pixel = self.info.bytes_per_pixel();
        let offset = y * self.info.stride + x * bytes_per_pixel;

        if offset + bytes_per_pixel <= self.buffer.len() {
            match bytes_per_pixel {
                4 => {
                    let ptr = unsafe { self.buffer.as_ptr().add(offset) as *const u32 };
                    unsafe { ptr.read_volatile() }
                }
                3 => {
                    let ptr = self.buffer.as_ptr();
                    unsafe {
                        let b0 = ptr.add(offset).read_volatile() as u32;
                        let b1 = ptr.add(offset + 1).read_volatile() as u32;
                        let b2 = ptr.add(offset + 2).read_volatile() as u32;
                        b0 | (b1 << 8) | (b2 << 16)
                    }
                }
                2 => {
                    let ptr = unsafe { self.buffer.as_ptr().add(offset) as *const u16 };
                    unsafe { ptr.read_volatile() as u32 }
                }
                _ => 0,
            }
        } else {
            0
        }
    }

    /// Convert a pixel value back to a Color
    fn pixel_value_to_color(&self, pixel_value: u32) -> Color {
        match self.info.pixel_format {
            PixelFormat::RGBA8888 => Color::from_rgba32(pixel_value),
            PixelFormat::BGRA8888 => {
                let b = ((pixel_value >> 24) & 0xFF) as u8;
                let g = ((pixel_value >> 16) & 0xFF) as u8;
                let r = ((pixel_value >> 8) & 0xFF) as u8;
                let a = (pixel_value & 0xFF) as u8;
                Color::new(r, g, b, a)
            }
            PixelFormat::RGB888 => {
                let r = ((pixel_value >> 16) & 0xFF) as u8;
                let g = ((pixel_value >> 8) & 0xFF) as u8;
                let b = (pixel_value & 0xFF) as u8;
                Color::rgb(r, g, b)
            }
            PixelFormat::RGB565 => {
                let r = (((pixel_value >> 11) & 0x1F) * 255 / 31) as u8;
                let g = (((pixel_value >> 5) & 0x3F) * 255 / 63) as u8;
                let b = ((pixel_value & 0x1F) * 255 / 31) as u8;
                Color::rgb(r, g, b)
            }
            PixelFormat::RGB555 => {
                let r = (((pixel_value >> 10) & 0x1F) * 255 / 31) as u8;
                let g = (((pixel_value >> 5) & 0x1F) * 255 / 31) as u8;
                let b = ((pixel_value & 0x1F) * 255 / 31) as u8;
                Color::rgb(r, g, b)
            }
        }
    }
}

/// Global framebuffer instance
static mut GLOBAL_FRAMEBUFFER: Option<SimpleFramebuffer> = None;
static mut GLOBAL_FRAMEBUFFER_INITIALIZED: bool = false;

/// Simplified framebuffer for actual pixel operations
pub struct SimpleFramebuffer {
    pub buffer: *mut u8,
    pub width: usize,
    pub height: usize,
    pub stride: usize,
    pub pixel_format: PixelFormat,
}

unsafe impl Send for SimpleFramebuffer {}
unsafe impl Sync for SimpleFramebuffer {}

impl SimpleFramebuffer {
    pub fn new(buffer: *mut u8, width: usize, height: usize, pixel_format: PixelFormat) -> Self {
        let bytes_per_pixel = pixel_format.bytes_per_pixel();
        let stride = width * bytes_per_pixel;
        Self {
            buffer,
            width,
            height,
            stride,
            pixel_format,
        }
    }

    pub fn set_pixel(&mut self, x: usize, y: usize, color: Color) {
        if x >= self.width || y >= self.height {
            return;
        }

        let bytes_per_pixel = self.pixel_format.bytes_per_pixel();
        let offset = y * self.stride + x * bytes_per_pixel;
        let pixel_value = color.to_pixel_format(self.pixel_format);

        unsafe {
            match bytes_per_pixel {
                1 => {
                    *self.buffer.add(offset) = pixel_value as u8;
                }
                2 => {
                    let ptr = self.buffer.add(offset) as *mut u16;
                    *ptr = pixel_value as u16;
                }
                3 => {
                    let ptr = self.buffer.add(offset);
                    *ptr = (pixel_value & 0xFF) as u8;
                    *ptr.add(1) = ((pixel_value >> 8) & 0xFF) as u8;
                    *ptr.add(2) = ((pixel_value >> 16) & 0xFF) as u8;
                }
                4 => {
                    let ptr = self.buffer.add(offset) as *mut u32;
                    *ptr = pixel_value;
                }
                _ => {}
            }
        }
    }

    pub fn clear(&mut self, color: Color) {
        for y in 0..self.height {
            for x in 0..self.width {
                self.set_pixel(x, y, color);
            }
        }
    }

    pub fn fill_rect(&mut self, rect: Rect, color: Color) {
        let end_x = (rect.x + rect.width).min(self.width);
        let end_y = (rect.y + rect.height).min(self.height);
        
        for y in rect.y..end_y {
            for x in rect.x..end_x {
                self.set_pixel(x, y, color);
            }
        }
    }

    pub fn draw_rect(&mut self, rect: Rect, color: Color, thickness: usize) {
        // Top and bottom borders
        for i in 0..thickness {
            if rect.y + i < self.height {
                self.fill_rect(Rect::new(rect.x, rect.y + i, rect.width, 1), color);
            }
            if rect.y + rect.height > i && rect.y + rect.height - i - 1 < self.height {
                self.fill_rect(Rect::new(rect.x, rect.y + rect.height - i - 1, rect.width, 1), color);
            }
        }
        
        // Left and right borders
        for i in 0..thickness {
            if rect.x + i < self.width {
                self.fill_rect(Rect::new(rect.x + i, rect.y, 1, rect.height), color);
            }
            if rect.x + rect.width > i && rect.x + rect.width - i - 1 < self.width {
                self.fill_rect(Rect::new(rect.x + rect.width - i - 1, rect.y, 1, rect.height), color);
            }
        }
    }
}

/// Initialize the global framebuffer
pub fn init(info: FramebufferInfo, _double_buffered: bool) -> Result<(), &'static str> {
    unsafe {
        GLOBAL_FRAMEBUFFER = Some(SimpleFramebuffer::new(
            info.physical_address as *mut u8,
            info.width,
            info.height,
            info.pixel_format,
        ));
        GLOBAL_FRAMEBUFFER_INITIALIZED = true;
    }
    Ok(())
}

/// Initialize framebuffer using an existing buffer provided by the bootloader
pub fn init_with_buffer(
    buffer: &'static mut [u8],
    info: FramebufferInfo,
    _double_buffered: bool,
) -> Result<(), &'static str> {
    unsafe {
        GLOBAL_FRAMEBUFFER = Some(SimpleFramebuffer::new(
            buffer.as_mut_ptr(),
            info.width,
            info.height,
            info.pixel_format,
        ));
        GLOBAL_FRAMEBUFFER_INITIALIZED = true;
    }
    Ok(())
}

/// Get a reference to the global framebuffer
pub fn framebuffer() -> Option<bool> {
    // Simplified implementation - just return whether framebuffer is initialized
    unsafe { Some(GLOBAL_FRAMEBUFFER_INITIALIZED) }
}

/// Get framebuffer information if initialized
pub fn get_info() -> Option<FramebufferInfo> {
    unsafe {
        if let Some(ref fb) = GLOBAL_FRAMEBUFFER {
            Some(FramebufferInfo::new(
                fb.width,
                fb.height,
                fb.pixel_format,
                fb.buffer as usize,
                false,
            ))
        } else {
            None
        }
    }
}

/// Clear the screen with a color
pub fn clear_screen(color: Color) {
    unsafe {
        if let Some(ref mut fb) = GLOBAL_FRAMEBUFFER {
            fb.clear(color);
        }
    }
}

/// Set a pixel on the screen
pub fn set_pixel(x: usize, y: usize, color: Color) {
    unsafe {
        if let Some(ref mut fb) = GLOBAL_FRAMEBUFFER {
            fb.set_pixel(x, y, color);
        }
    }
}

/// Fill a rectangle on the screen
pub fn fill_rect(rect: Rect, color: Color) {
    unsafe {
        if let Some(ref mut fb) = GLOBAL_FRAMEBUFFER {
            fb.fill_rect(rect, color);
        }
    }
}

/// Draw a rectangle outline on the screen
pub fn draw_rect(rect: Rect, color: Color, thickness: usize) {
    unsafe {
        if let Some(ref mut fb) = GLOBAL_FRAMEBUFFER {
            fb.draw_rect(rect, color, thickness);
        }
    }
}

/// Present the current frame
pub fn present() {
    // Simplified implementation for no-std environment
    // In a real implementation, this would present the current frame
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{serial_print, serial_println};

    #[cfg(feature = "disabled-tests")] // #[cfg(feature = "disabled-tests")] // #[test]
    fn test_color_conversions() {
        serial_print!("test_color_conversions... ");
        let color = Color::rgb(255, 128, 64);
        let rgba32 = color.to_rgba32();
        let converted = Color::from_rgba32(rgba32);
        assert_eq!(color.r, converted.r);
        assert_eq!(color.g, converted.g);
        assert_eq!(color.b, converted.b);
        serial_println!("[ok]");
    }

    #[cfg(feature = "disabled-tests")] // #[cfg(feature = "disabled-tests")] // #[test]
    fn test_rect_operations() {
        serial_print!("test_rect_operations... ");
        let rect1 = Rect::new(10, 10, 20, 20);
        let rect2 = Rect::new(25, 25, 20, 20);
        let rect3 = Rect::new(15, 15, 20, 20);

        assert!(!rect1.intersects(&rect2));
        assert!(rect1.intersects(&rect3));
        assert!(rect1.contains(15, 15));
        assert!(!rect1.contains(35, 35));
        serial_println!("[ok]");
    }

    #[cfg(feature = "disabled-tests")] // #[cfg(feature = "disabled-tests")] // #[test]
    fn test_pixel_format_bytes() {
        serial_print!("test_pixel_format_bytes... ");
        assert_eq!(PixelFormat::RGBA8888.bytes_per_pixel(), 4);
        assert_eq!(PixelFormat::RGB888.bytes_per_pixel(), 3);
        assert_eq!(PixelFormat::RGB565.bytes_per_pixel(), 2);
        serial_println!("[ok]");
    }
}
