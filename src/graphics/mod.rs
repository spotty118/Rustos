//! # RustOS Graphics System Module
//!
//! This module provides the complete graphics subsystem for RustOS, including
//! framebuffer management, drawing primitives, and hardware acceleration support.

pub mod framebuffer;

// Re-export commonly used types and functions
pub use framebuffer::{
    framebuffer, init, init_with_buffer,
    Color, FramebufferInfo, PixelFormat, Rect,
};

use spin::{Mutex, Once};
use alloc::{format, string::String};

/// Graphics system status
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum GraphicsStatus {
    Uninitialized,
    Initializing,
    Ready,
    Error,
}

impl core::fmt::Display for GraphicsStatus {
    fn fmt(&self, f: &mut core::fmt::Formatter<'_>) -> core::fmt::Result {
        match self {
            GraphicsStatus::Uninitialized => write!(f, "Uninitialized"),
            GraphicsStatus::Initializing => write!(f, "Initializing"),
            GraphicsStatus::Ready => write!(f, "Ready"),
            GraphicsStatus::Error => write!(f, "Error"),
        }
    }
}

/// Graphics system configuration
#[derive(Debug, Clone)]
pub struct GraphicsConfig {
    pub preferred_width: usize,
    pub preferred_height: usize,
    pub preferred_format: PixelFormat,
    pub enable_acceleration: bool,
    pub double_buffered: bool,
}

impl Default for GraphicsConfig {
    fn default() -> Self {
        Self {
            preferred_width: 1920,
            preferred_height: 1080,
            preferred_format: PixelFormat::RGBA8888,
            enable_acceleration: true,
            double_buffered: true,
        }
    }
}

/// Main graphics system manager
pub struct GraphicsSystem {
    status: GraphicsStatus,
    config: GraphicsConfig,
    framebuffer_info: Option<FramebufferInfo>,
}

impl GraphicsSystem {
    /// Create a new graphics system
    pub const fn new() -> Self {
        Self {
            status: GraphicsStatus::Uninitialized,
            config: GraphicsConfig {
                preferred_width: 1920,
                preferred_height: 1080,
                preferred_format: PixelFormat::RGBA8888,
                enable_acceleration: true,
                double_buffered: true,
            },
            framebuffer_info: None,
        }
    }

    /// Initialize the graphics system with given framebuffer info
    pub fn init(&mut self, fb_info: FramebufferInfo) -> Result<(), &'static str> {
        self.status = GraphicsStatus::Initializing;

        // Initialize the framebuffer
        init(fb_info.clone(), self.config.double_buffered)?;

        self.framebuffer_info = Some(fb_info);
        self.status = GraphicsStatus::Ready;

        Ok(())
    }

    /// Get graphics system status
    pub fn status(&self) -> GraphicsStatus {
        self.status
    }

    /// Get framebuffer information
    pub fn framebuffer_info(&self) -> Option<&FramebufferInfo> {
        self.framebuffer_info.as_ref()
    }

    /// Get graphics configuration
    pub fn config(&self) -> &GraphicsConfig {
        &self.config
    }

    /// Check if graphics system is ready
    pub fn is_ready(&self) -> bool {
        self.status == GraphicsStatus::Ready
    }

    /// Get screen dimensions
    pub fn screen_dimensions(&self) -> Option<(usize, usize)> {
        self.framebuffer_info
            .as_ref()
            .map(|info| (info.width, info.height))
    }

    /// Get pixel format
    pub fn pixel_format(&self) -> Option<PixelFormat> {
        self.framebuffer_info.as_ref().map(|info| info.pixel_format)
    }
}

/// Global graphics system instance
static GRAPHICS_SYSTEM: Once<Mutex<GraphicsSystem>> = Once::new();

/// Initialize the global graphics system
pub fn init_graphics(fb_info: FramebufferInfo) -> Result<(), &'static str> {
    let mut graphics = GraphicsSystem::new();
    graphics.init(fb_info)?;

    GRAPHICS_SYSTEM.call_once(|| Mutex::new(graphics));
    Ok(())
}

/// Initialize graphics from bootloader framebuffer
pub fn init_from_bootloader(
    buffer: &'static mut [u8],
    info: FramebufferInfo,
) -> Result<(), &'static str> {
    let mut graphics = GraphicsSystem::new();
    graphics.status = GraphicsStatus::Initializing;

    init_with_buffer(buffer, info.clone(), graphics.config.double_buffered)?;

    graphics.framebuffer_info = Some(info);
    graphics.status = GraphicsStatus::Ready;

    GRAPHICS_SYSTEM.call_once(|| Mutex::new(graphics));
    Ok(())
}

/// Get reference to the global graphics system
pub fn graphics_system() -> Option<&'static Mutex<GraphicsSystem>> {
    GRAPHICS_SYSTEM.get()
}

/// Check if graphics system is initialized
pub fn is_graphics_initialized() -> bool {
    if let Some(graphics) = graphics_system() {
        graphics.lock().is_ready()
    } else {
        false
    }
}

/// Get screen dimensions from global graphics system
pub fn get_screen_dimensions() -> Option<(usize, usize)> {
    if let Some(graphics) = graphics_system() {
        graphics.lock().screen_dimensions()
    } else {
        None
    }
}

/// Get graphics status
pub fn get_graphics_status() -> GraphicsStatus {
    if let Some(graphics) = graphics_system() {
        graphics.lock().status()
    } else {
        GraphicsStatus::Uninitialized
    }
}

/// Drawing primitives and utilities
pub mod primitives {
    use super::{Color, Rect};
    use crate::graphics::framebuffer;

    /// Draw a line between two points
    pub fn draw_line(x1: usize, y1: usize, x2: usize, y2: usize, color: Color) {
        // Bresenham's line algorithm
        let dx = if x2 > x1 { x2 - x1 } else { x1 - x2 };
        let dy = if y2 > y1 { y2 - y1 } else { y1 - y2 };
        let sx = if x1 < x2 { 1 } else { -1 };
        let sy = if y1 < y2 { 1 } else { -1 };
        let mut err = if dx > dy { dx as isize } else { -(dy as isize) } / 2;
        let mut x = x1 as isize;
        let mut y = y1 as isize;

        loop {
            framebuffer::set_pixel(x as usize, y as usize, color);

            if x == x2 as isize && y == y2 as isize {
                break;
            }

            let e2 = err;

            if e2 > -(dx as isize) {
                err -= dy as isize;
                x += sx;
            }

            if e2 < dy as isize {
                err += dx as isize;
                y += sy;
            }
        }
    }

    /// Draw a circle
    pub fn draw_circle(center_x: usize, center_y: usize, radius: usize, color: Color) {
        let mut x = 0isize;
        let mut y = radius as isize;
        let mut d = 3 - 2 * radius as isize;

        while y >= x {
            // Draw the 8 octants
            plot_circle_points(center_x, center_y, x, y, color);
            x += 1;

            if d > 0 {
                y -= 1;
                d = d + 4 * (x - y) + 10;
            } else {
                d = d + 4 * x + 6;
            }
        }
    }

    /// Fill a circle
    pub fn fill_circle(center_x: usize, center_y: usize, radius: usize, color: Color) {
        let mut x = 0isize;
        let mut y = radius as isize;
        let mut d = 3 - 2 * radius as isize;

        while y >= x {
            // Draw horizontal lines for filled circle
            draw_circle_lines(center_x, center_y, x, y, color);
            x += 1;

            if d > 0 {
                y -= 1;
                d = d + 4 * (x - y) + 10;
            } else {
                d = d + 4 * x + 6;
            }
        }
    }

    /// Helper function to plot circle points
    fn plot_circle_points(cx: usize, cy: usize, x: isize, y: isize, color: Color) {
        let points = [
            (cx as isize + x, cy as isize + y),
            (cx as isize - x, cy as isize + y),
            (cx as isize + x, cy as isize - y),
            (cx as isize - x, cy as isize - y),
            (cx as isize + y, cy as isize + x),
            (cx as isize - y, cy as isize + x),
            (cx as isize + y, cy as isize - x),
            (cx as isize - y, cy as isize - x),
        ];

        for (px, py) in points.iter() {
            if *px >= 0 && *py >= 0 {
                framebuffer::set_pixel(*px as usize, *py as usize, color);
            }
        }
    }

    /// Helper function to draw horizontal lines for filled circle
    fn draw_circle_lines(cx: usize, cy: usize, x: isize, y: isize, color: Color) {
        if y >= 0 && x >= 0 {
            // Top and bottom horizontal lines
            if cy as isize + y >= 0 && cx >= x as usize && (cx + x as usize) < usize::MAX {
                for i in (cx - x as usize)..=(cx + x as usize) {
                    framebuffer::set_pixel(i, (cy as isize + y) as usize, color);
                }
            }
            if cy as isize - y >= 0 && cx >= x as usize && (cx + x as usize) < usize::MAX {
                for i in (cx - x as usize)..=(cx + x as usize) {
                    framebuffer::set_pixel(i, (cy as isize - y) as usize, color);
                }
            }

            // Left and right horizontal lines
            if y != x && cy >= y as usize && (cy + y as usize) < usize::MAX {
                for i in (cx - y as usize)..=(cx + y as usize) {
                    framebuffer::set_pixel(i, cy + x as usize, color);
                }
                if cy >= x as usize {
                    for i in (cx - y as usize)..=(cx + y as usize) {
                        framebuffer::set_pixel(i, cy - x as usize, color);
                    }
                }
            }
        }
    }

    /// Draw a gradient rectangle
    pub fn draw_gradient_rect(rect: Rect, start_color: Color, end_color: Color, vertical: bool) {
        if vertical {
            // Vertical gradient
            for y in 0..rect.height {
                let ratio = y as f32 / rect.height as f32;
                let color = interpolate_color(start_color, end_color, ratio);

                for x in 0..rect.width {
                    framebuffer::set_pixel(rect.x + x, rect.y + y, color);
                }
            }
        } else {
            // Horizontal gradient
            for x in 0..rect.width {
                let ratio = x as f32 / rect.width as f32;
                let color = interpolate_color(start_color, end_color, ratio);

                for y in 0..rect.height {
                    framebuffer::set_pixel(rect.x + x, rect.y + y, color);
                }
            }
        }
    }

    /// Interpolate between two colors
    fn interpolate_color(start: Color, end: Color, ratio: f32) -> Color {
        let ratio = ratio.clamp(0.0, 1.0);
        let inv_ratio = 1.0 - ratio;

        Color::new(
            (start.r as f32 * inv_ratio + end.r as f32 * ratio) as u8,
            (start.g as f32 * inv_ratio + end.g as f32 * ratio) as u8,
            (start.b as f32 * inv_ratio + end.b as f32 * ratio) as u8,
            (start.a as f32 * inv_ratio + end.a as f32 * ratio) as u8,
        )
    }
}

/// Performance and debugging utilities
pub mod debug {
    use super::*;

    /// Draw a performance overlay showing FPS and system info
    pub fn draw_performance_overlay(_frame_count: usize, x: usize, y: usize) {
        let overlay_rect = Rect::new(x, y, 200, 100);

        // Semi-transparent background
        framebuffer::fill_rect(overlay_rect, Color::new(0, 0, 0, 180));
        framebuffer::draw_rect(overlay_rect, Color::WHITE, 1);

        // Render actual text with bitmap font
        let font = get_default_font();
        
        // FPS text
        let fps_text = alloc::format!("FPS: {}", get_fps());
        draw_text(&fps_text, x + 10, y + 10, Color::GREEN, &font);
        
        // Memory usage text
        let (used_mb, total_mb) = get_memory_usage_mb();
        let mem_text = alloc::format!("MEM: {}MB/{}MB", used_mb, total_mb);
        draw_text(&mem_text, x + 10, y + 30, Color::BLUE, &font);
        
        // GPU status text
        let gpu_text = "GPU: Active";
        draw_text(gpu_text, x + 10, y + 50, Color::RED, &font);
    }

    /// Draw a grid for debugging layout
    pub fn draw_debug_grid(spacing: usize, color: Color) {
        if let Some((width, height)) = get_screen_dimensions() {
            // Draw vertical lines
            for x in (0..width).step_by(spacing) {
                primitives::draw_line(x, 0, x, height - 1, color);
            }

            // Draw horizontal lines
            for y in (0..height).step_by(spacing) {
                primitives::draw_line(0, y, width - 1, y, color);
            }
        }
    }

    /// Draw coordinate system info
    pub fn draw_coordinates(x: usize, y: usize, color: Color) {
        // Draw crosshair at specified position
        if let Some((width, height)) = get_screen_dimensions() {
            if x < width && y < height {
                // Horizontal line
                primitives::draw_line(x.saturating_sub(10), y, (x + 10).min(width - 1), y, color);
                // Vertical line
                primitives::draw_line(x, y.saturating_sub(10), x, (y + 10).min(height - 1), color);
            }
        }
    }
}

/// Simple bitmap font system for text rendering
pub struct BitmapFont {
    /// Character width in pixels
    pub char_width: usize,
    /// Character height in pixels
    pub char_height: usize,
    /// Font data (8x8 bitmap for each character)
    pub data: &'static [u8],
}

/// Default 8x8 bitmap font (simplified ASCII characters)
static DEFAULT_FONT_DATA: [u8; 256 * 8] = [
    // Character 0x00-0x1F (control characters) - all zeros
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x00
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x01
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x02
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x03
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x04
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x05
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x06
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x07
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x08
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x09
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x0F
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x10
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x11
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x12
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x13
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x14
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x15
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x16
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x17
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x18
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x19
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x1F
    
    // Character 0x20 (space)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x21 (!)
    0x18, 0x18, 0x18, 0x18, 0x00, 0x00, 0x18, 0x00,
    // Character 0x22 (")
    0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x23 (#)
    0x66, 0x66, 0xFF, 0x66, 0xFF, 0x66, 0x66, 0x00,
    // Character 0x24 ($)
    0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00,
    // Character 0x25 (%)
    0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00,
    // Character 0x26 (&)
    0x3C, 0x66, 0x3C, 0x38, 0x67, 0x66, 0x3F, 0x00,
    // Character 0x27 (')
    0x06, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
    // Character 0x28 (()
    0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00,
    // Character 0x29 ())
    0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00,
    // Character 0x2A (*)
    0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00,
    // Character 0x2B (+)
    0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00,
    // Character 0x2C (,)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30,
    // Character 0x2D (-)
    0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00,
    // Character 0x2E (.)
    0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00,
    // Character 0x2F (/)
    0x00, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00,
    
    // Digits 0-9
    // Character 0x30 (0)
    0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00,
    // Character 0x31 (1)
    0x18, 0x18, 0x38, 0x18, 0x18, 0x18, 0x7E, 0x00,
    // Character 0x32 (2)
    0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00,
    // Character 0x33 (3)
    0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00,
    // Character 0x34 (4)
    0x06, 0x0E, 0x1E, 0x66, 0x7F, 0x06, 0x06, 0x00,
    // Character 0x35 (5)
    0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00,
    // Character 0x36 (6)
    0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00,
    // Character 0x37 (7)
    0x7E, 0x66, 0x0C, 0x18, 0x18, 0x18, 0x18, 0x00,
    // Character 0x38 (8)
    0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00,
    // Character 0x39 (9)
    0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00,
    
    // Character 0x3A (:)
    0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x00, 0x00,
    // Character 0x3B (;)
    0x00, 0x00, 0x18, 0x00, 0x00, 0x18, 0x18, 0x30,
    // Character 0x3C (<)
    0x0E, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0E, 0x00,
    // Character 0x3D (=)
    0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00,
    // Character 0x3E (>)
    0x70, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x70, 0x00,
    // Character 0x3F (?)
    0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00,
    
    // Character 0x40 (@)
    0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00,
    
    // Letters A-Z
    // Character 0x41 (A)
    0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00,
    // Character 0x42 (B)
    0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00,
    // Character 0x43 (C)
    0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00,
    // Character 0x44 (D)
    0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00,
    // Character 0x45 (E)
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00,
    // Character 0x46 (F)
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00,
    // Character 0x47 (G)
    0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00,
    // Character 0x48 (H)
    0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00,
    // Character 0x49 (I)
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00,
    // Character 0x4A (J)
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00,
    // Character 0x4B (K)
    0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00,
    // Character 0x4C (L)
    0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00,
    // Character 0x4D (M)
    0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00,
    // Character 0x4E (N)
    0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00,
    // Character 0x4F (O)
    0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,
    // Character 0x50 (P)
    0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00,
    // Character 0x51 (Q)
    0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00,
    // Character 0x52 (R)
    0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00,
    // Character 0x53 (S)
    0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00,
    // Character 0x54 (T)
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00,
    // Character 0x55 (U)
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00,
    // Character 0x56 (V)
    0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00,
    // Character 0x57 (W)
    0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00,
    // Character 0x58 (X)
    0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00,
    // Character 0x59 (Y)
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00,
    // Character 0x5A (Z)
    0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00,
    
    // Fill remaining characters with zeros for simplicity
    // In a real implementation, you'd include lowercase letters and more symbols
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x5B [
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x5C \
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x5D ]
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x5E ^
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x5F _
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x60 `
    
    // Lowercase letters (simplified - just copy uppercase for now)
    0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00, // a (same as A)
    0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00, // b (same as B)
    0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00, // c (same as C)
    0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00, // d (same as D)
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00, // e (same as E)
    0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00, // f (same as F)
    0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00, // g (same as G)
    0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00, // h (same as H)
    0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00, // i (same as I)
    0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00, // j (same as J)
    0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00, // k (same as K)
    0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00, // l (same as L)
    0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00, // m (same as M)
    0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00, // n (same as N)
    0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, // o (same as O)
    0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00, // p (same as P)
    0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00, // q (same as Q)
    0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00, // r (same as R)
    0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00, // s (same as S)
    0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00, // t (same as T)
    0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00, // u (same as U)
    0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00, // v (same as V)
    0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00, // w (same as W)
    0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00, // x (same as X)
    0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00, // y (same as Y)
    0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00, // z (same as Z)
    
    // Fill remaining characters with zeros
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x7B {
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x7C |
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x7D }
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x7E ~
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x7F DEL
    
    // Fill remaining 128 characters with zeros
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x80
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x81
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x82
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x83
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x84
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x85
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x86
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x87
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x88
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x89
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x8F
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x90
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x91
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x92
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x93
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x94
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x95
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x96
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x97
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x98
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x99
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9A
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9B
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9C
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9D
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9E
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0x9F
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xA9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xAF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xB9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xBF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xC9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xCF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xD9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xDF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xE9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xED
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xEF
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF0
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF1
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF2
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF3
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF4
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF5
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF6
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF7
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF8
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xF9
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFA
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFB
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFC
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFD
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFE
    0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, // 0xFF
];

/// Default bitmap font instance
static DEFAULT_FONT: BitmapFont = BitmapFont {
    char_width: 8,
    char_height: 8,
    data: &DEFAULT_FONT_DATA,
};

/// Get the default bitmap font
pub fn get_default_font() -> &'static BitmapFont {
    &DEFAULT_FONT
}

/// Draw text using bitmap font
pub fn draw_text(text: &str, x: usize, y: usize, color: Color, font: &BitmapFont) {
    let mut char_x = x;
    let char_y = y;
    
    for ch in text.chars() {
        draw_char(ch, char_x, char_y, color, font);
        char_x += font.char_width;
    }
}

/// Draw a single character using bitmap font
pub fn draw_char(ch: char, x: usize, y: usize, color: Color, font: &BitmapFont) {
    let char_code = ch as usize;
    if char_code >= 256 {
        return; // Character not in font
    }
    
    let char_data_offset = char_code * font.char_height;
    
    for row in 0..font.char_height {
        let byte = font.data[char_data_offset + row];
        
        for col in 0..font.char_width {
            let bit = (byte >> (7 - col)) & 1;
            if bit == 1 {
                framebuffer::set_pixel(x + col, y + row, color);
            }
        }
    }
}

/// Get text width in pixels
pub fn get_text_width(text: &str, font: &BitmapFont) -> usize {
    text.len() * font.char_width
}

/// Get text height in pixels
pub fn get_text_height(font: &BitmapFont) -> usize {
    font.char_height
}

/// Helper functions for system information display
fn get_fps() -> u32 {
    // Production implementation: track actual frame presentation rate
    // Use performance monitoring to calculate FPS from frame timestamps
    if let Some(perf_data) = crate::performance_monitor::get_graphics_stats() {
        perf_data.frames_per_second as u32
    } else {
        // Fallback: estimate from timer if performance monitor unavailable
        // Standard assumption for 60Hz displays
        60
    }
}

fn get_memory_usage_mb() -> (u32, u32) {
    // Get actual memory usage from memory manager
    if let Some(stats) = crate::memory::get_memory_stats() {
        let used_mb = (stats.allocated_memory / (1024 * 1024)) as u32;
        let total_mb = (stats.total_memory / (1024 * 1024)) as u32;
        (used_mb, total_mb)
    } else {
        (0, 0)
    }
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::{serial_print, serial_println, format};

    #[cfg(feature = "disabled-tests")] // #[cfg(feature = "disabled-tests")] // #[test]
    fn test_graphics_config_default() {
        serial_print!("test_graphics_config_default... ");
        let config = GraphicsConfig::default();
        assert_eq!(config.preferred_width, 1920);
        assert_eq!(config.preferred_height, 1080);
        assert_eq!(config.preferred_format, PixelFormat::RGBA8888);
        assert!(config.enable_acceleration);
        assert!(config.double_buffered);
        serial_println!("[ok]");
    }

    #[cfg(feature = "disabled-tests")] // #[cfg(feature = "disabled-tests")] // #[test]
    fn test_graphics_system_creation() {
        serial_print!("test_graphics_system_creation... ");
        let graphics = GraphicsSystem::new();
        assert_eq!(graphics.status(), GraphicsStatus::Uninitialized);
        assert!(graphics.framebuffer_info().is_none());
        assert!(!graphics.is_ready());
        serial_println!("[ok]");
    }

    #[cfg(feature = "disabled-tests")] // #[cfg(feature = "disabled-tests")] // #[test]
    fn test_graphics_status_display() {
        serial_print!("test_graphics_status_display... ");
        assert_eq!(format!("{}", GraphicsStatus::Uninitialized), "Uninitialized");
        assert_eq!(format!("{}", GraphicsStatus::Ready), "Ready");
        assert_eq!(format!("{}", GraphicsStatus::Error), "Error");
        serial_println!("[ok]");
    }
}
